esphome:
  name: smartrv-tankpro-v3
  friendly_name: SmartRV TankPro v3
  name_add_mac_suffix: true
  comment: "ESPHome production firmware for SmartRV TankPro (factory AP provisioning)."
  on_boot:
    priority: -10
    then:
      - switch.turn_off: tank_valve_relay
      - globals.set:
          id: fill_in_progress
          value: 'false'
      - globals.set:
          id: drain_in_progress
          value: 'false'
      - globals.set:
          id: fill_above_stop_seen
          value: 'false'
      - globals.set:
          id: guard_over_stop_counter
          value: '0'
      - text_sensor.template.publish:
          id: fault_description
          state: "None"
      - text_sensor.template.publish:
          id: fault_code
          state: "0"

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 8MB
  framework:
    type: arduino

logger:
  baud_rate: 115200
  level: DEBUG

debug:

api:
  reboot_timeout: 0s

ota:
  - platform: esphome
    password: 'smartrv'

wifi:
  ap:
    ssid: "SmartRV-TankPro-Setup"
    password: "changeme"

captive_portal:

improv_serial:

web_server:
  port: 80

# Globals for on-device fill automation parameters and state
globals:
  # User-adjustable stop level for automatic fill (%)
  - id: fill_stop_level
    type: float
    restore_value: true
    initial_value: '90.0'
  - id: fill_in_progress
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: drain_in_progress
    type: bool
    restore_value: false
    initial_value: 'false'
  # User-adjustable stop level for automatic drain (%)
  - id: drain_stop_level
    type: float
    restore_value: true
    initial_value: '10.0'
  - id: drain_start_level
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: drain_last_level
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: drain_start_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: drain_last_change_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: drain_timeout_ms
    type: uint32_t
    restore_value: true
    initial_value: '45000'  
  - id: fault_active
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: fault_code_int
    type: int
    restore_value: false
    initial_value: '0'
  - id: safety_override
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: freeze_protection_enabled
    type: bool
    restore_value: true
    initial_value: 'false'
  # Minimum temperature before freeze protection triggers (C)
  - id: freeze_protection_threshold_c
    type: float
    restore_value: true
    initial_value: '2.0'
  - id: last_temp_update_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: temp_timeout_ms
    type: uint32_t
    restore_value: true
    initial_value: '300000'
  - id: fill_above_stop_seen
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: guard_over_stop_counter
    type: int
    restore_value: false
    initial_value: '0'
  # Calibration points for level sensor (set via buttons in UI)
  - id: level_empty_volts
    type: float
    restore_value: true
    initial_value: '0.5'    # default empty calibration point
  - id: level_full_volts
    type: float
    restore_value: true
    initial_value: '2.5'    # default full calibration point

light:
  - platform: neopixelbus
    id: status_led
    name: "Status LED"
    entity_category: config
    pin: GPIO48
    variant: WS2812
    num_leds: 1
    type: GRB
    method: esp32_rmt_1
    default_transition_length: 0s
    restore_mode: ALWAYS_OFF

script:
  - id: status_led_flash_red
    then:
      - repeat:
          count: 3
          then:
            - light.turn_on:
                id: status_led
                brightness: 60%
                red: 100%
                green: 0%
                blue: 0%
            - delay: 300ms
            - light.turn_off: status_led
            - delay: 200ms

  # Main fill automation (self-contained on device)
  - id: fill_tank_script
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(safety_override) || id(fault_active);'
          then:
            - logger.log: "Fill start ignored: safety override or fault active."
          else:
            - globals.set:
                id: fill_in_progress
                value: 'true'
            - globals.set:
                id: fill_above_stop_seen
                value: 'false'
            - switch.turn_on: tank_valve_relay
            - while:
                condition:
                  lambda: |-
                    const float level = id(tank_level).state;
                    const float stop_level = id(fill_stop_level);
                    if (!id(fill_in_progress)) return false;
                    if (isnan(level)) return true;
                    if (level >= stop_level) {
                      if (id(fill_above_stop_seen)) {
                        return false;  // two consecutive readings above stop
                      } else {
                        id(fill_above_stop_seen) = true;
                        return true;
                      }
                    }
                    id(fill_above_stop_seen) = false;
                    return true;
                then:
                  - delay: 3s
            - switch.turn_off: tank_valve_relay
            - globals.set:
                id: fill_in_progress
                value: 'false'
            - globals.set:
                id: fill_above_stop_seen
                value: 'false'

  # Drain automation
  - id: drain_tank_script
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(safety_override) || id(fault_active);'
          then:
            - logger.log: "Drain start ignored: safety override or fault active."
          else:
            - if:
                condition:
                  lambda: 'return id(fill_in_progress);'
                then:
                  - logger.log: "Drain start requested but fill is active; aborting drain."
                else:
                  - globals.set:
                      id: drain_in_progress
                      value: 'true'
                  - lambda: |-
                      id(drain_start_level) = id(tank_level).state;
                      id(drain_last_level) = id(tank_level).state;
                      id(drain_start_ms) = millis();
                      id(drain_last_change_ms) = millis();
                  - switch.turn_on: tank_valve_relay
                  - while:
                      condition:
                        lambda: |-
                          if (!id(drain_in_progress)) return false;
                          const float level = id(tank_level).state;
                          const float stop_level = id(drain_stop_level);
                          const unsigned long now = millis();
                          // update change timer if level moved meaningfully (>0.5%)
                          if (!isnan(level) && !isnan(id(drain_last_level)) && fabs(level - id(drain_last_level)) > 0.5f) {
                            id(drain_last_change_ms) = now;
                            id(drain_last_level) = level;
                          }
                          // stop if below/equal target
                          if (!isnan(level) && level <= stop_level) return false;
                          // stop if stagnant for configured timeout
                          if (now - id(drain_last_change_ms) >= id(drain_timeout_ms)) return false;
                          return true;
                      then:
                        - delay: 3s
                  - switch.turn_off: tank_valve_relay
                  - globals.set:
                      id: drain_in_progress
                      value: 'false'

interval:
  # Safety guard: close valve if level meets/exceeds stop level regardless of state
  - interval: 2s
    then:
      - if:
          condition:
            lambda: |-
              const float level = id(tank_level).state;
              const bool above = !isnan(level) && level >= id(fill_stop_level);
              if (above) {
                id(guard_over_stop_counter) += 1;
              } else {
                id(guard_over_stop_counter) = 0;
              }
              return !id(safety_override) && id(tank_valve_relay).state && above && id(guard_over_stop_counter) >= 2;
          then:
            - if:
                condition:
                  lambda: 'return id(fill_in_progress);'
                then:
                  - logger.log: "Safety guard: level at/above stop threshold during fill; closing valve (normal stop)."
                  - switch.turn_off: tank_valve_relay
                  - globals.set:
                      id: fill_in_progress
                      value: 'false'
                  - globals.set:
                      id: drain_in_progress
                      value: 'false'
                  - globals.set:
                      id: guard_over_stop_counter
                      value: '0'
                else:
                  - logger.log: "Safety guard: valve open without fill_in_progress and level at/above stop; closing valve and flagging fault."
                  - switch.turn_off: tank_valve_relay
                  - globals.set:
                      id: fill_in_progress
                      value: 'false'
                  - globals.set:
                      id: drain_in_progress
                      value: 'false'
                  - globals.set:
                      id: fault_active
                      value: 'true'
                  - globals.set:
                      id: fault_code_int
                      value: '2'
                  - globals.set:
                      id: guard_over_stop_counter
                      value: '0'
                  - text_sensor.template.publish:
                      id: fault_description
                      state: "Valve open without active fill"
                  - text_sensor.template.publish:
                      id: fault_code
                      state: "2"
                  - script.execute: status_led_flash_red
  # Fault annunciation: pulse buzzer and LED while in fault state
  - interval: 1s
    then:
      - if:
          condition:
            lambda: 'return id(fault_active) && !id(safety_override);'
          then:
            - light.turn_on:
                id: status_led
                brightness: 60%
                red: 100%
                green: 0%
                blue: 0%
            - switch.turn_on: tank_buzzer
            - delay: 300ms
            - switch.turn_off: tank_buzzer
            - light.turn_off: status_led
  # Freeze protection / temp sensor health check
  - interval: 5s
    then:
      - if:
          condition:
            lambda: 'return id(freeze_protection_enabled) && !id(safety_override);'
          then:
            - lambda: |-
                const float t = id(tank_temperature).state;
                const bool timed_out = id(last_temp_update_ms) > 0 && (millis() - id(last_temp_update_ms) > id(temp_timeout_ms));
                if (id(fault_active) && id(fault_code_int) != 3 && id(fault_code_int) != 4) {
                  // Another fault is active; do not override with freeze protection logic.
                  return;
                }
                if (isnan(t) || timed_out) {
                  if (id(fault_code_int) != 4 || !id(fault_active)) {
                    ESP_LOGI("freeze_protect", "Temp sensor failure while freeze protection enabled; setting fault code 4 (nan=%d timed_out=%d).", isnan(t), timed_out);
                    id(fault_active) = true;
                    id(fault_code_int) = 4;
                    id(fill_in_progress) = false;
                    id(drain_in_progress) = false;
                    id(tank_valve_relay).turn_off();
                    id(fault_description).publish_state("Temp Sensor Failure");
                    id(fault_code).publish_state("4");
                    id(status_led_flash_red).execute();
                  }
                  return;
                }
                if (t <= id(freeze_protection_threshold_c)) {
                  if (id(fault_code_int) != 3 || !id(fault_active)) {
                    ESP_LOGI("freeze_protect", "Freeze protection active: temp %.2fC at/below threshold %.2fC.", t, id(freeze_protection_threshold_c));
                    id(fault_active) = true;
                    id(fault_code_int) = 3;
                    id(fill_in_progress) = false;
                    id(drain_in_progress) = false;
                    id(fault_description).publish_state("Freeze protection");
                    id(fault_code).publish_state("3");
                    id(status_led_flash_red).execute();
                  }
                  id(tank_valve_relay).turn_on();
                }
                // If temp is healthy and above threshold, do nothing here; clearing fault handled elsewhere.

one_wire:
  - platform: gpio
    pin: GPIO47
    id: tank_temp_bus

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO16
      mode: INPUT_PULLUP
      inverted: true
    name: "Button"
    on_press:
      - logger.log: "Button pressed"

  - platform: status
    name: "Status"

  - platform: gpio
    pin:
      number: GPIO8
      mode: INPUT_PULLUP
      inverted: true
    name: "Leak Sensor"
    device_class: moisture
    on_press:
      - if:
          condition:
            lambda: 'return !id(safety_override);'
          then:
            - logger.log: "Leak detected: triggering critical fault and shutting down valve."
            - globals.set:
                id: fault_active
                value: 'true'
            - globals.set:
                id: fault_code_int
                value: '1'
            - globals.set:
                id: fill_in_progress
                value: 'false'
            - globals.set:
                id: drain_in_progress
                value: 'false'
            - switch.turn_off: tank_valve_relay
            - text_sensor.template.publish:
                id: fault_description
                state: "Leak detected"
            - text_sensor.template.publish:
                id: fault_code
                state: "1"
            - script.execute: status_led_flash_red

  # Expose fill automation state

sensor:
  - platform: adc
    id: tank_level_voltage
    pin: GPIO1
    name: "Tank Level Voltage"
    update_interval: 2s
    attenuation: 0db
    unit_of_measurement: "V"
    icon: "mdi:water"
    internal: true

  - platform: template
    id: tank_level
    name: "Tank Level"
    unit_of_measurement: "%"
    icon: "mdi:water"
    update_interval: 2s
    lambda: |-
      const float volts = id(tank_level_voltage).state;
      const float empty_v = id(level_empty_volts);
      const float full_v = id(level_full_volts);
      if (isnan(volts) || full_v <= empty_v) return NAN;
      float pct = (volts - empty_v) * 100.0f / (full_v - empty_v);
      if (pct < 0) pct = 0;
      if (pct > 100) pct = 100;
      return pct;

  - platform: dallas_temp
    one_wire_id: tank_temp_bus
    id: tank_temperature
    name: "Tank Temperature"
    filters:
      - lambda: |-
          if (isnan(x)) return NAN;
          // Treat common bad readings as invalid so state goes to NAN/unknown
          if (x == 85.0f || x == 0.0f || x < -55.0f || x > 125.0f) return NAN;
          return x;
    on_value:
      then:
        - lambda: 'id(last_temp_update_ms) = millis();'
        - logger.log:
            format: "Tank temperature: %.2fÂ°C"
            args: ["x"]

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  - platform: uptime
    name: "Uptime"
    update_interval: 60s

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "Module IP"
    ssid:
      name: "Connected SSID"
    bssid:
      name: "Connected BSSID"
    mac_address:
      name: "Module MAC"
  - platform: template
    id: fault_description
    name: "Fault Description"
    update_interval: never
    icon: "mdi:alert-circle-outline"
    entity_category: diagnostic
    internal: false
  - platform: template
    id: fault_code
    name: "Fault Code"
    entity_category: diagnostic
    lambda: |-
      char buf[8];
      snprintf(buf, sizeof(buf), "%d", id(fault_code_int));
      return std::string(buf);
    update_interval: 3s
  - platform: template
    id: system_status
    name: "Status"
    icon: "mdi:information"
    lambda: |-
      if (id(fault_active)) return std::string("Fault");
      if (id(fill_in_progress)) return std::string("Filling");
      if (id(drain_in_progress)) return std::string("Draining");
      if (id(tank_valve_relay).state) return std::string("Valve Open");
      return std::string("Idle");
    update_interval: 3s
  - platform: template
    id: freeze_protection_state
    name: "Freeze Protection State"
    icon: "mdi:snowflake-check"
    entity_category: diagnostic
    lambda: |-
      return id(freeze_protection_enabled) ? std::string("Enabled") : std::string("Disabled");
    update_interval: 10s

number:
  # User-tunable fill stop threshold exposed to Home Assistant
  - platform: template
    id: fill_stop_level_number
    name: "Fill Stop Level"
    entity_category: config
    unit_of_measurement: "%"
    icon: "mdi:water-check"
    min_value: 0
    max_value: 100
    step: 1
    lambda: 'return id(fill_stop_level);'
    set_action:
      - globals.set:
          id: fill_stop_level
          value: !lambda 'return (float) x;'
  - platform: template
    id: freeze_protection_threshold_number
    name: "Freeze Protection Threshold"
    entity_category: config
    unit_of_measurement: "C"
    icon: "mdi:snowflake"
    min_value: 0.1
    max_value: 5
    step: 0.1
    lambda: 'return id(freeze_protection_threshold_c);'
    set_action:
      - globals.set:
          id: freeze_protection_threshold_c
          value: !lambda 'return (float) x;'
  - platform: template
    id: drain_stop_level_number
    name: "Drain Stop Level"
    entity_category: config
    unit_of_measurement: "%"
    icon: "mdi:water-remove"
    min_value: 0
    max_value: 100
    step: 1
    lambda: 'return id(drain_stop_level);'
    set_action:
      - globals.set:
          id: drain_stop_level
          value: !lambda 'return (float) x;'
  - platform: template
    id: drain_timeout_seconds
    name: "Drain Timeout"
    entity_category: config
    unit_of_measurement: "s"
    icon: "mdi:timer-off"
    min_value: 5
    max_value: 300
    step: 5
    lambda: 'return (float) id(drain_timeout_ms) / 1000.0f;'
    set_action:
      - globals.set:
          id: drain_timeout_ms
          value: !lambda 'return (uint32_t)(x * 1000.0f);'

switch:
  - platform: gpio
    id: tank_valve_relay
    pin: GPIO5
    name: "Valve Override"
    icon: "mdi:valve"
    restore_mode: ALWAYS_OFF

  - platform: gpio
    id: tank_buzzer
    pin: GPIO4
    name: "Tank Buzzer"
    icon: "mdi:volume-high"
    entity_category: config
    restore_mode: ALWAYS_OFF
  - platform: template
    id: freeze_protection_switch
    name: "Freeze Protection"
    icon: "mdi:snowflake-alert"
    entity_category: config
    optimistic: false
    lambda: 'return id(freeze_protection_enabled);'
    turn_on_action:
      - logger.log: "Freeze protection enabled."
      - globals.set:
          id: freeze_protection_enabled
          value: 'true'
    turn_off_action:
      - logger.log: "Freeze protection disabled."
      - globals.set:
          id: freeze_protection_enabled
          value: 'false'
  - platform: template
    id: safety_override_switch
    name: "Safety Override"
    icon: "mdi:shield-off"
    entity_category: config
    optimistic: false
    lambda: 'return id(safety_override);'
    turn_on_action:
      - logger.log: "Safety override enabled: fault triggers and automations disabled."
      - globals.set:
          id: safety_override
          value: 'true'
      - globals.set:
          id: fault_active
          value: 'false'
      - globals.set:
          id: fault_code_int
          value: '0'
      - text_sensor.template.publish:
          id: fault_description
          state: "Override active"
      - text_sensor.template.publish:
          id: fault_code
          state: "0"
    turn_off_action:
      - logger.log: "Safety override disabled: normal monitoring resumed."
      - globals.set:
          id: safety_override
          value: 'false'
      - globals.set:
          id: fault_active
          value: 'false'
      - globals.set:
          id: fault_code_int
          value: '0'
      - text_sensor.template.publish:
          id: fault_description
          state: "None"
      - text_sensor.template.publish:
          id: fault_code
          state: "0"

button:
  - platform: restart
    id: restart_device
    name: "Restart Device"
  - platform: template
    name: "Set Level Empty"
    icon: "mdi:water-minus"
    entity_category: config
    on_press:
      - globals.set:
          id: level_empty_volts
          value: !lambda 'return (float) id(tank_level_voltage).state;'
      - logger.log:
          format: "Saved empty calibration: %.3f V"
          args: ["id(tank_level_voltage).state"]
  - platform: template
    name: "Set Level Full"
    icon: "mdi:water-plus"
    entity_category: config
    on_press:
      - globals.set:
          id: level_full_volts
          value: !lambda 'return (float) id(tank_level_voltage).state;'
      - logger.log:
          format: "Saved full calibration: %.3f V"
          args: ["id(tank_level_voltage).state"]
  - platform: template
    name: "Reset Configuration"
    icon: "mdi:backup-restore"
    entity_category: config
    on_press:
      - logger.log: "Resetting configuration to defaults."
      # Restore calibration defaults
      - globals.set:
          id: level_empty_volts
          value: '0.5'
      - globals.set:
          id: level_full_volts
          value: '2.5'
      # Restore thresholds and protections
      - globals.set:
          id: fill_stop_level
          value: '90.0'
      - globals.set:
          id: drain_stop_level
          value: '10.0'
      - globals.set:
          id: freeze_protection_threshold_c
          value: '2.0'
      - globals.set:
          id: freeze_protection_enabled
          value: 'false'
      # Clear state and faults
      - globals.set:
          id: fill_in_progress
          value: 'false'
      - globals.set:
          id: drain_in_progress
          value: 'false'
      - globals.set:
          id: fill_above_stop_seen
          value: 'false'
      - globals.set:
          id: guard_over_stop_counter
          value: '0'
      - globals.set:
          id: fault_active
          value: 'false'
      - globals.set:
          id: fault_code_int
          value: '0'
      - switch.turn_off: tank_valve_relay
      - switch.turn_off: tank_buzzer
      - light.turn_off: status_led
      - text_sensor.template.publish:
          id: fault_description
          state: "None"
      - text_sensor.template.publish:
          id: fault_code
          state: "0"
  - platform: template
    name: "Fill Tank"
    icon: "mdi:water-plus"
    on_press:
      - if:
          condition:
            lambda: 'return id(fault_active) || id(safety_override);'
          then:
            - logger.log: "Fill request ignored: fault or safety override active."
          else:
            - if:
                condition:
                  lambda: 'return id(fill_in_progress);'
                then:
                  - logger.log: "Fill button pressed while running: stopping fill."
                  - globals.set:
                      id: fill_in_progress
                      value: 'false'
                  - switch.turn_off: tank_valve_relay
                else:
                  - if:
                      condition:
                        lambda: 'return !isnan(id(tank_level).state) && id(tank_level).state >= id(fill_stop_level);'
                      then:
                        - logger.log: "Fill button pressed: tank already at/above stop level."
                      else:
                        - logger.log: "Fill button pressed: starting fill."
                        - script.execute: fill_tank_script
  - platform: template
    name: "Drain Tank"
    icon: "mdi:water-remove"
    on_press:
      - if:
          condition:
            lambda: 'return id(fault_active) || id(safety_override);'
          then:
            - logger.log: "Drain request ignored: fault or safety override active."
          else:
            - if:
                condition:
                  lambda: 'return id(drain_in_progress);'
                then:
                  - logger.log: "Drain button pressed while draining: stopping drain."
                  - globals.set:
                      id: drain_in_progress
                      value: 'false'
                  - switch.turn_off: tank_valve_relay
                else:
                  - logger.log: "Drain button pressed: starting drain."
                  - script.execute: drain_tank_script
  - platform: template
    name: "Clear Faults"
    icon: "mdi:alert-circle-check"
    on_press:
      - if:
          condition:
            lambda: 'return id(fault_code_int) == 0;'
          then:
            - logger.log: "Clear Faults pressed with no active fault; ignoring."
          else:
            - logger.log: "Clearing faults and resetting state."
            - globals.set:
                id: fault_active
                value: 'false'
            - globals.set:
                id: fault_code_int
                value: '0'
            - globals.set:
                id: fill_in_progress
                value: 'false'
            - globals.set:
                id: drain_in_progress
                value: 'false'
            - switch.turn_off: tank_valve_relay
            - switch.turn_off: tank_buzzer
            - text_sensor.template.publish:
                id: fault_description
                state: "None"
            - text_sensor.template.publish:
                id: fault_code
                state: "0"
